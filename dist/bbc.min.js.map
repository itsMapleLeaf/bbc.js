{"version":3,"sources":["../src/bbc.js"],"names":[],"mappings":"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","file":"bbc.min.js","sourcesContent":["'use strict'\n\nconst START_TAG = /^\\[([a-z]+)(?:=([^[]+))?\\]/i\nconst END_TAG = /^\\[\\/([a-z]+)\\]/i\n\nfunction collectText (input) {\n  if (input.length < 1) return ''\n  if (input.match(START_TAG) || input.match(END_TAG)) return ''\n  return input[0] + collectText(input.slice(1))\n}\n\nfunction matchStartTag (input) {\n  const [text, tag, param = null] = input.match(START_TAG) || []\n  if (text) return {type: 'start-tag', text, tag: tag.toLowerCase(), param}\n}\n\nfunction matchEndTag (input) {\n  const [text, tag] = input.match(END_TAG) || []\n  if (text) return {type: 'end-tag', text, tag: tag.toLowerCase()}\n}\n\nfunction matchText (input) {\n  const text = collectText(input)\n  return {type: 'text', text}\n}\n\nfunction tokenize (input) {\n  if (input.length < 1) return []\n\n  const node = matchStartTag(input) || matchEndTag(input) || matchText(input)\n  return [node].concat(tokenize(input.slice(node.text.length)))\n}\n\nfunction createTree (tokens) {\n  function parseTextNode (parser) {\n    const token = tokens[parser.position]\n    if (token.type === 'text' || token.type === 'end-tag') {\n      parser.position++\n      return {type: 'text', text: token.text}\n    }\n  }\n\n  function parseTagPair (parser) {\n    let token = tokens[parser.position]\n    if (token.type === 'start-tag') {\n      const node = {\n        type: 'tag-pair',\n        tag: token.tag,\n        param: token.param,\n        children: [],\n      }\n\n      token = tokens[++parser.position]\n\n      while (\n        parser.position < tokens.length &&\n        token.type !== 'end-tag' &&\n        token.tag !== node.tag\n      ) {\n        node.children.push(walk(parser))\n        token = tokens[parser.position]\n      }\n\n      parser.position++\n\n      return node\n    }\n  }\n\n  function walk (parser) {\n    if (parser.position >= tokens.length) return\n    return parseTextNode(parser) || parseTagPair(parser)\n  }\n\n  const parser = {position: 0, tree: []}\n  while (parser.position < tokens.length) {\n    parser.tree.push(walk(parser))\n  }\n  return parser.tree\n}\n\nfunction parse (tokens) {\n  return createTree(tokens)\n}\n\nfunction defaultRenderer (content, tag, param) {\n  if (param != null) return `[${tag}=${param}]${content}[/${tag}]`\n  return `[${tag}]${content}[/${tag}]`\n}\n\nfunction renderNode (node, tagset) {\n  if (node.type === 'text') {\n    return node.text\n  } else if (node.type === 'tag-pair') {\n    const content = node.children.map(renderNode).join('')\n    const renderer = tagset[node.tag] || defaultRenderer\n    return renderer(content, node.tag, node.param)\n  }\n}\n\nfunction parseBBC (bbc) {\n  return parse(tokenize(bbc))\n}\n\nfunction renderBBC (bbc, tagset = {}) {\n  return parseBBC(bbc).map(node => renderNode(node, tagset)).join('')\n}\n\nconst tags = {\n  common: {\n    b: content => `<strong>${content}</strong>`,\n    i: content => `<em>${content}</em>`,\n    u: content => `<u>${content}</u>`,\n    img: content => `<img src=\"${content}\">`,\n    sup: content => `<sup>${content}</sup>`,\n    sub: content => `<sub>${content}</sub>`,\n    big: content => `<big>${content}</big>`,\n    small: content => `<small>${content}</small>`,\n  },\n}\n\nmodule.exports = {tokenize, parseBBC, renderBBC, tags}\n"]}