{"version":3,"sources":["../src/bbc.js"],"names":[],"mappings":"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","file":"bbc.js","sourcesContent":["'use strict'\n\nconst START_TAG = /^\\[([a-z]+)(?:=([^[]+))?\\]/i\nconst END_TAG = /^\\[\\/([a-z]+)\\]/i\n\nfunction collectText (input) {\n  if (input.length < 1) return ''\n  if (input.match(START_TAG) || input.match(END_TAG)) return ''\n  return input[0] + collectText(input.slice(1))\n}\n\nfunction matchStartTag (input) {\n  const [text, tag, param = null] = input.match(START_TAG) || []\n  if (text) return {type: 'start-tag', text, tag: tag.toLowerCase(), param}\n}\n\nfunction matchEndTag (input) {\n  const [text, tag] = input.match(END_TAG) || []\n  if (text) return {type: 'end-tag', text, tag: tag.toLowerCase()}\n}\n\nfunction matchText (input) {\n  const text = collectText(input)\n  return {type: 'text', text}\n}\n\nfunction tokenize (input) {\n  if (input.length < 1) return []\n\n  const node = matchStartTag(input) || matchEndTag(input) || matchText(input)\n  return [node].concat(tokenize(input.slice(node.text.length)))\n}\n\nfunction createTree (tokens) {\n  function parseTextNode (parser) {\n    const token = tokens[parser.position]\n    if (token.type === 'text' || token.type === 'end-tag') {\n      parser.position++\n      return {type: 'text', text: token.text}\n    }\n  }\n\n  function parseTagPair (parser) {\n    let token = tokens[parser.position]\n    if (token.type === 'start-tag') {\n      const node = {\n        type: 'tag-pair',\n        tag: token.tag,\n        param: token.param,\n        children: [],\n      }\n\n      token = tokens[++parser.position]\n\n      while (\n        parser.position < tokens.length &&\n        token.type !== 'end-tag' &&\n        token.tag !== node.tag\n      ) {\n        node.children.push(walk(parser))\n        token = tokens[parser.position]\n      }\n\n      parser.position++\n\n      return node\n    }\n  }\n\n  function walk (parser) {\n    if (parser.position >= tokens.length) return\n    return parseTextNode(parser) || parseTagPair(parser)\n  }\n\n  const parser = {position: 0, tree: []}\n  while (parser.position < tokens.length) {\n    parser.tree.push(walk(parser))\n  }\n  return parser.tree\n}\n\nfunction parse (tokens) {\n  return createTree(tokens)\n}\n\nfunction defaultRenderer (content, tag, param) {\n  if (param != null) return `[${tag}=${param}]${content}[/${tag}]`\n  return `[${tag}]${content}[/${tag}]`\n}\n\nfunction renderNode (node, tagset) {\n  if (node.type === 'text') {\n    return node.text\n  } else if (node.type === 'tag-pair') {\n    const content = node.children.map(renderNode).join('')\n    const renderer = tagset[node.tag] || defaultRenderer\n    return renderer(content, node.tag, node.param)\n  }\n}\n\nfunction parseBBC (bbc) {\n  return parse(tokenize(bbc))\n}\n\nfunction renderBBC (bbc, tagset = {}) {\n  return parseBBC(bbc).map(node => renderNode(node, tagset)).join('')\n}\n\nconst tags = {\n  common: {\n    b: content => `<strong>${content}</strong>`,\n    i: content => `<em>${content}</em>`,\n    u: content => `<u>${content}</u>`,\n    img: content => `<img src=\"${content}\">`,\n    sup: content => `<sup>${content}</sup>`,\n    sub: content => `<sub>${content}</sub>`,\n    big: content => `<big>${content}</big>`,\n    small: content => `<small>${content}</small>`,\n  },\n}\n\nmodule.exports = {tokenize, parseBBC, renderBBC, tags}\n"]}